type Account implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Account address"""
  wallet: String!
  assetBalances: [AssetBalance!]
  historicalAssetBalances: [HistoricalAssetBalance!]
}

type AccountConnection {
  totalCount: Int!
  edges: [AccountEdge!]!
  pageInfo: PageInfo!
}

input AccountCreateInput {
  wallet: String!
}

type AccountEdge {
  node: Account!
  cursor: String!
}

enum AccountOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  wallet_ASC
  wallet_DESC
}

input AccountUpdateInput {
  wallet: String
}

input AccountWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  wallet_eq: String
  wallet_contains: String
  wallet_startsWith: String
  wallet_endsWith: String
  wallet_in: [String!]
  assetBalances_none: AssetBalanceWhereInput
  assetBalances_some: AssetBalanceWhereInput
  assetBalances_every: AssetBalanceWhereInput
  historicalAssetBalances_none: HistoricalAssetBalanceWhereInput
  historicalAssetBalances_some: HistoricalAssetBalanceWhereInput
  historicalAssetBalances_every: HistoricalAssetBalanceWhereInput
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
}

input AccountWhereUniqueInput {
  id: ID!
}

type Asset implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  assetId: String!
  price: Float
  qty: BigInt
}

type AssetBalance implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  account: Account!
  accountId: String!
  assetId: String!
  balance: BigInt!
}

type AssetBalanceConnection {
  totalCount: Int!
  edges: [AssetBalanceEdge!]!
  pageInfo: PageInfo!
}

input AssetBalanceCreateInput {
  account: ID!
  assetId: String!
  balance: String!
}

type AssetBalanceEdge {
  node: AssetBalance!
  cursor: String!
}

enum AssetBalanceOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  account_ASC
  account_DESC
  assetId_ASC
  assetId_DESC
  balance_ASC
  balance_DESC
}

input AssetBalanceUpdateInput {
  account: ID
  assetId: String
  balance: String
}

input AssetBalanceWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  assetId_eq: String
  assetId_contains: String
  assetId_startsWith: String
  assetId_endsWith: String
  assetId_in: [String!]
  balance_eq: BigInt
  balance_gt: BigInt
  balance_gte: BigInt
  balance_lt: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  account: AccountWhereInput
  AND: [AssetBalanceWhereInput!]
  OR: [AssetBalanceWhereInput!]
}

input AssetBalanceWhereUniqueInput {
  id: ID!
}

type AssetConnection {
  totalCount: Int!
  edges: [AssetEdge!]!
  pageInfo: PageInfo!
}

input AssetCreateInput {
  assetId: String!
  price: Float
  qty: String
}

type AssetEdge {
  node: Asset!
  cursor: String!
}

enum AssetOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  assetId_ASC
  assetId_DESC
  price_ASC
  price_DESC
  qty_ASC
  qty_DESC
}

input AssetUpdateInput {
  assetId: String
  price: Float
  qty: String
}

input AssetWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  assetId_eq: String
  assetId_contains: String
  assetId_startsWith: String
  assetId_endsWith: String
  assetId_in: [String!]
  price_eq: Float
  price_gt: Float
  price_gte: Float
  price_lt: Float
  price_lte: Float
  price_in: [Float!]
  qty_eq: BigInt
  qty_gt: BigInt
  qty_gte: BigInt
  qty_lt: BigInt
  qty_lte: BigInt
  qty_in: [BigInt!]
  AND: [AssetWhereInput!]
  OR: [AssetWhereInput!]
}

input AssetWhereUniqueInput {
  id: ID!
}

interface BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModel implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModelUUID implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

input BaseWhereInput {
  id_eq: String
  id_in: [String!]
  createdAt_eq: String
  createdAt_lt: String
  createdAt_lte: String
  createdAt_gt: String
  createdAt_gte: String
  createdById_eq: String
  updatedAt_eq: String
  updatedAt_lt: String
  updatedAt_lte: String
  updatedAt_gt: String
  updatedAt_gte: String
  updatedById_eq: String
  deletedAt_all: Boolean
  deletedAt_eq: String
  deletedAt_lt: String
  deletedAt_lte: String
  deletedAt_gt: String
  deletedAt_gte: String
  deletedById_eq: String
}

"""GraphQL representation of BigInt"""
scalar BigInt

type CategoryMetadata {
  name: String
  ticker: String
  img: String
  color: String
}

input CategoryMetadataCreateInput {
  name: String
  ticker: String
  img: String
  color: String
}

input CategoryMetadataInput {
  name: String
  ticker: String
  img: String
  color: String
}

input CategoryMetadataUpdateInput {
  name: String
  ticker: String
  img: String
  color: String
}

input CategoryMetadataWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  name_eq: String
  name_contains: String
  name_startsWith: String
  name_endsWith: String
  name_in: [String!]
  ticker_eq: String
  ticker_contains: String
  ticker_startsWith: String
  ticker_endsWith: String
  ticker_in: [String!]
  img_eq: String
  img_contains: String
  img_startsWith: String
  img_endsWith: String
  img_in: [String!]
  color_eq: String
  color_contains: String
  color_startsWith: String
  color_endsWith: String
  color_in: [String!]
  AND: [CategoryMetadataWhereInput!]
  OR: [CategoryMetadataWhereInput!]
}

input CategoryMetadataWhereUniqueInput {
  id: ID!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

interface DeleteResponse {
  id: ID!
}

type HistoricalAssetBalance implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  account: Account!
  accountId: String!
  event: String!
  assetId: String!
  amount: BigInt!
  balance: BigInt!
  blockNumber: Int!
  timestamp: BigInt!
}

type HistoricalAssetBalanceConnection {
  totalCount: Int!
  edges: [HistoricalAssetBalanceEdge!]!
  pageInfo: PageInfo!
}

input HistoricalAssetBalanceCreateInput {
  account: ID!
  event: String!
  assetId: String!
  amount: String!
  balance: String!
  blockNumber: Float!
  timestamp: String!
}

type HistoricalAssetBalanceEdge {
  node: HistoricalAssetBalance!
  cursor: String!
}

enum HistoricalAssetBalanceOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  account_ASC
  account_DESC
  event_ASC
  event_DESC
  assetId_ASC
  assetId_DESC
  amount_ASC
  amount_DESC
  balance_ASC
  balance_DESC
  blockNumber_ASC
  blockNumber_DESC
  timestamp_ASC
  timestamp_DESC
}

input HistoricalAssetBalanceUpdateInput {
  account: ID
  event: String
  assetId: String
  amount: String
  balance: String
  blockNumber: Float
  timestamp: String
}

input HistoricalAssetBalanceWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  event_eq: String
  event_contains: String
  event_startsWith: String
  event_endsWith: String
  event_in: [String!]
  assetId_eq: String
  assetId_contains: String
  assetId_startsWith: String
  assetId_endsWith: String
  assetId_in: [String!]
  amount_eq: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_lt: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  balance_eq: BigInt
  balance_gt: BigInt
  balance_gte: BigInt
  balance_lt: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  blockNumber_eq: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  timestamp_eq: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  account: AccountWhereInput
  AND: [HistoricalAssetBalanceWhereInput!]
  OR: [HistoricalAssetBalanceWhereInput!]
}

input HistoricalAssetBalanceWhereUniqueInput {
  id: ID!
}

type HistoricalAssetPrice implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  assetId: String!
  dPrice: Float!
  dQty: BigInt!
  price: Float!
  qty: BigInt!
  event: String!
  blockNumber: Int!
  timestamp: BigInt!
}

type HistoricalAssetPriceConnection {
  totalCount: Int!
  edges: [HistoricalAssetPriceEdge!]!
  pageInfo: PageInfo!
}

input HistoricalAssetPriceCreateInput {
  assetId: String!
  dPrice: Float!
  dQty: String!
  price: Float!
  qty: String!
  event: String!
  blockNumber: Float!
  timestamp: String!
}

type HistoricalAssetPriceEdge {
  node: HistoricalAssetPrice!
  cursor: String!
}

enum HistoricalAssetPriceOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  assetId_ASC
  assetId_DESC
  dPrice_ASC
  dPrice_DESC
  dQty_ASC
  dQty_DESC
  price_ASC
  price_DESC
  qty_ASC
  qty_DESC
  event_ASC
  event_DESC
  blockNumber_ASC
  blockNumber_DESC
  timestamp_ASC
  timestamp_DESC
}

input HistoricalAssetPriceUpdateInput {
  assetId: String
  dPrice: Float
  dQty: String
  price: Float
  qty: String
  event: String
  blockNumber: Float
  timestamp: String
}

input HistoricalAssetPriceWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  assetId_eq: String
  assetId_contains: String
  assetId_startsWith: String
  assetId_endsWith: String
  assetId_in: [String!]
  dPrice_eq: Float
  dPrice_gt: Float
  dPrice_gte: Float
  dPrice_lt: Float
  dPrice_lte: Float
  dPrice_in: [Float!]
  dQty_eq: BigInt
  dQty_gt: BigInt
  dQty_gte: BigInt
  dQty_lt: BigInt
  dQty_lte: BigInt
  dQty_in: [BigInt!]
  price_eq: Float
  price_gt: Float
  price_gte: Float
  price_lt: Float
  price_lte: Float
  price_in: [Float!]
  qty_eq: BigInt
  qty_gt: BigInt
  qty_gte: BigInt
  qty_lt: BigInt
  qty_lte: BigInt
  qty_in: [BigInt!]
  event_eq: String
  event_contains: String
  event_startsWith: String
  event_endsWith: String
  event_in: [String!]
  blockNumber_eq: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  timestamp_eq: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  AND: [HistoricalAssetPriceWhereInput!]
  OR: [HistoricalAssetPriceWhereInput!]
}

input HistoricalAssetPriceWhereUniqueInput {
  id: ID!
}

type HistoricalPool implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  poolId: Int!
  event: String!
  ztgQty: BigInt!
  blockNumber: Int!
  timestamp: BigInt!
}

type HistoricalPoolConnection {
  totalCount: Int!
  edges: [HistoricalPoolEdge!]!
  pageInfo: PageInfo!
}

input HistoricalPoolCreateInput {
  poolId: Float!
  event: String!
  ztgQty: String!
  blockNumber: Float!
  timestamp: String!
}

type HistoricalPoolEdge {
  node: HistoricalPool!
  cursor: String!
}

enum HistoricalPoolOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  poolId_ASC
  poolId_DESC
  event_ASC
  event_DESC
  ztgQty_ASC
  ztgQty_DESC
  blockNumber_ASC
  blockNumber_DESC
  timestamp_ASC
  timestamp_DESC
}

input HistoricalPoolUpdateInput {
  poolId: Float
  event: String
  ztgQty: String
  blockNumber: Float
  timestamp: String
}

input HistoricalPoolWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  poolId_eq: Int
  poolId_gt: Int
  poolId_gte: Int
  poolId_lt: Int
  poolId_lte: Int
  poolId_in: [Int!]
  event_eq: String
  event_contains: String
  event_startsWith: String
  event_endsWith: String
  event_in: [String!]
  ztgQty_eq: BigInt
  ztgQty_gt: BigInt
  ztgQty_gte: BigInt
  ztgQty_lt: BigInt
  ztgQty_lte: BigInt
  ztgQty_in: [BigInt!]
  blockNumber_eq: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  timestamp_eq: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  AND: [HistoricalPoolWhereInput!]
  OR: [HistoricalPoolWhereInput!]
}

input HistoricalPoolWhereUniqueInput {
  id: ID!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type Market implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  marketId: Int!
  creator: String!
  creation: String!
  creatorFee: Int
  oracle: String!
  outcomeAssets: [String!]!
  slug: String
  question: String
  description: String
  categories: CategoryMetadata
  tags: [String!]
  img: String
  marketType: MarketType!
  period: MarketPeriod!
  end: BigInt!
  scoringRule: String!
  status: String!
  poolId: Int
  report: MarketReport
  resolvedOutcome: String
  mdm: MarketDisputeMechanism!
  marketHistory: MarketHistory
}

type MarketConnection {
  totalCount: Int!
  edges: [MarketEdge!]!
  pageInfo: PageInfo!
}

input MarketCreateInput {
  marketId: Float!
  creator: String!
  creation: String!
  creatorFee: Float
  oracle: String!
  outcomeAssets: [String!]!
  slug: String
  question: String
  description: String
  categories: CategoryMetadataInput
  tags: [String!]
  img: String
  marketType: MarketTypeInput!
  period: MarketPeriodInput!
  end: String!
  scoringRule: String!
  status: String!
  poolId: Float
  report: MarketReportInput
  resolvedOutcome: String
  mdm: MarketDisputeMechanismInput!
  marketHistory: MarketHistoryInput
}

type MarketDisputeMechanism {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}

input MarketDisputeMechanismCreateInput {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}

input MarketDisputeMechanismInput {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}

input MarketDisputeMechanismUpdateInput {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}

input MarketDisputeMechanismWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  authorized_eq: String
  authorized_contains: String
  authorized_startsWith: String
  authorized_endsWith: String
  authorized_in: [String!]
  court_eq: Boolean
  court_in: [Boolean!]
  simpleDisputes_eq: Boolean
  simpleDisputes_in: [Boolean!]
  AND: [MarketDisputeMechanismWhereInput!]
  OR: [MarketDisputeMechanismWhereInput!]
}

input MarketDisputeMechanismWhereUniqueInput {
  id: ID!
}

type MarketEdge {
  node: Market!
  cursor: String!
}

type MarketHistory {
  event: String
  status: String
  poolId: Int
  report: MarketReport
  resolvedOutcome: String
  blockNumber: Int
  timestamp: String
}

input MarketHistoryCreateInput {
  event: String
  status: String
  poolId: Float
  resolvedOutcome: String
  blockNumber: Float
  timestamp: String
}

input MarketHistoryInput {
  event: String
  status: String
  poolId: Int
  report: MarketReportInput
  resolvedOutcome: String
  blockNumber: Int
  timestamp: String
}

input MarketHistoryUpdateInput {
  event: String
  status: String
  poolId: Float
  resolvedOutcome: String
  blockNumber: Float
  timestamp: String
}

input MarketHistoryWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  event_eq: String
  event_contains: String
  event_startsWith: String
  event_endsWith: String
  event_in: [String!]
  status_eq: String
  status_contains: String
  status_startsWith: String
  status_endsWith: String
  status_in: [String!]
  poolId_eq: Int
  poolId_gt: Int
  poolId_gte: Int
  poolId_lt: Int
  poolId_lte: Int
  poolId_in: [Int!]
  resolvedOutcome_eq: String
  resolvedOutcome_contains: String
  resolvedOutcome_startsWith: String
  resolvedOutcome_endsWith: String
  resolvedOutcome_in: [String!]
  blockNumber_eq: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  timestamp_eq: String
  timestamp_contains: String
  timestamp_startsWith: String
  timestamp_endsWith: String
  timestamp_in: [String!]
  AND: [MarketHistoryWhereInput!]
  OR: [MarketHistoryWhereInput!]
}

input MarketHistoryWhereUniqueInput {
  id: ID!
}

enum MarketOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  marketId_ASC
  marketId_DESC
  creator_ASC
  creator_DESC
  creation_ASC
  creation_DESC
  creatorFee_ASC
  creatorFee_DESC
  oracle_ASC
  oracle_DESC
  slug_ASC
  slug_DESC
  question_ASC
  question_DESC
  description_ASC
  description_DESC
  img_ASC
  img_DESC
  end_ASC
  end_DESC
  scoringRule_ASC
  scoringRule_DESC
  status_ASC
  status_DESC
  poolId_ASC
  poolId_DESC
  resolvedOutcome_ASC
  resolvedOutcome_DESC
}

type MarketPeriod {
  block: String
  timestamp: String
}

input MarketPeriodCreateInput {
  block: String
  timestamp: String
}

input MarketPeriodInput {
  block: String
  timestamp: String
}

input MarketPeriodUpdateInput {
  block: String
  timestamp: String
}

input MarketPeriodWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  block_eq: String
  block_contains: String
  block_startsWith: String
  block_endsWith: String
  block_in: [String!]
  timestamp_eq: String
  timestamp_contains: String
  timestamp_startsWith: String
  timestamp_endsWith: String
  timestamp_in: [String!]
  AND: [MarketPeriodWhereInput!]
  OR: [MarketPeriodWhereInput!]
}

input MarketPeriodWhereUniqueInput {
  id: ID!
}

type MarketReport {
  at: Int!
  by: String!
  outcome: OutcomeReport!
}

input MarketReportCreateInput {
  at: Float!
  by: String!
}

input MarketReportInput {
  at: Int!
  by: String!
  outcome: OutcomeReportInput!
}

input MarketReportUpdateInput {
  at: Float
  by: String
}

input MarketReportWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  at_eq: Int
  at_gt: Int
  at_gte: Int
  at_lt: Int
  at_lte: Int
  at_in: [Int!]
  by_eq: String
  by_contains: String
  by_startsWith: String
  by_endsWith: String
  by_in: [String!]
  AND: [MarketReportWhereInput!]
  OR: [MarketReportWhereInput!]
}

input MarketReportWhereUniqueInput {
  id: ID!
}

type MarketType {
  categorical: String
  scalar: String
}

input MarketTypeCreateInput {
  categorical: String
  scalar: String
}

input MarketTypeInput {
  categorical: String
  scalar: String
}

input MarketTypeUpdateInput {
  categorical: String
  scalar: String
}

input MarketTypeWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  categorical_eq: String
  categorical_contains: String
  categorical_startsWith: String
  categorical_endsWith: String
  categorical_in: [String!]
  scalar_eq: String
  scalar_contains: String
  scalar_startsWith: String
  scalar_endsWith: String
  scalar_in: [String!]
  AND: [MarketTypeWhereInput!]
  OR: [MarketTypeWhereInput!]
}

input MarketTypeWhereUniqueInput {
  id: ID!
}

input MarketUpdateInput {
  marketId: Float
  creator: String
  creation: String
  creatorFee: Float
  oracle: String
  outcomeAssets: [String!]
  slug: String
  question: String
  description: String
  categories: CategoryMetadataInput
  tags: [String!]
  img: String
  marketType: MarketTypeInput
  period: MarketPeriodInput
  end: String
  scoringRule: String
  status: String
  poolId: Float
  report: MarketReportInput
  resolvedOutcome: String
  mdm: MarketDisputeMechanismInput
  marketHistory: MarketHistoryInput
}

input MarketWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  marketId_eq: Int
  marketId_gt: Int
  marketId_gte: Int
  marketId_lt: Int
  marketId_lte: Int
  marketId_in: [Int!]
  creator_eq: String
  creator_contains: String
  creator_startsWith: String
  creator_endsWith: String
  creator_in: [String!]
  creation_eq: String
  creation_contains: String
  creation_startsWith: String
  creation_endsWith: String
  creation_in: [String!]
  creatorFee_eq: Int
  creatorFee_gt: Int
  creatorFee_gte: Int
  creatorFee_lt: Int
  creatorFee_lte: Int
  creatorFee_in: [Int!]
  oracle_eq: String
  oracle_contains: String
  oracle_startsWith: String
  oracle_endsWith: String
  oracle_in: [String!]
  outcomeAssets_containsAll: [String!]
  outcomeAssets_containsNone: [String!]
  outcomeAssets_containsAny: [String!]
  slug_eq: String
  slug_contains: String
  slug_startsWith: String
  slug_endsWith: String
  slug_in: [String!]
  question_eq: String
  question_contains: String
  question_startsWith: String
  question_endsWith: String
  question_in: [String!]
  description_eq: String
  description_contains: String
  description_startsWith: String
  description_endsWith: String
  description_in: [String!]
  categories_json: JSONObject
  tags_containsAll: [String!]
  tags_containsNone: [String!]
  tags_containsAny: [String!]
  img_eq: String
  img_contains: String
  img_startsWith: String
  img_endsWith: String
  img_in: [String!]
  marketType_json: JSONObject
  period_json: JSONObject
  end_eq: BigInt
  end_gt: BigInt
  end_gte: BigInt
  end_lt: BigInt
  end_lte: BigInt
  end_in: [BigInt!]
  scoringRule_eq: String
  scoringRule_contains: String
  scoringRule_startsWith: String
  scoringRule_endsWith: String
  scoringRule_in: [String!]
  status_eq: String
  status_contains: String
  status_startsWith: String
  status_endsWith: String
  status_in: [String!]
  poolId_eq: Int
  poolId_gt: Int
  poolId_gte: Int
  poolId_lt: Int
  poolId_lte: Int
  poolId_in: [Int!]
  report_json: JSONObject
  resolvedOutcome_eq: String
  resolvedOutcome_contains: String
  resolvedOutcome_startsWith: String
  resolvedOutcome_endsWith: String
  resolvedOutcome_in: [String!]
  mdm_json: JSONObject
  marketHistory_json: JSONObject
  AND: [MarketWhereInput!]
  OR: [MarketWhereInput!]
}

input MarketWhereUniqueInput {
  id: ID!
}

type OutcomeReport {
  categorical: Int
  scalar: Int
}

input OutcomeReportCreateInput {
  categorical: Float
  scalar: Float
}

input OutcomeReportInput {
  categorical: Int
  scalar: Int
}

input OutcomeReportUpdateInput {
  categorical: Float
  scalar: Float
}

input OutcomeReportWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  categorical_eq: Int
  categorical_gt: Int
  categorical_gte: Int
  categorical_lt: Int
  categorical_lte: Int
  categorical_in: [Int!]
  scalar_eq: Int
  scalar_gt: Int
  scalar_gte: Int
  scalar_lt: Int
  scalar_lte: Int
  scalar_in: [Int!]
  AND: [OutcomeReportWhereInput!]
  OR: [OutcomeReportWhereInput!]
}

input OutcomeReportWhereUniqueInput {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pool implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  poolId: Int!
  baseAsset: String!
  marketId: Int!
  poolStatus: String!
  scoringRule: String!
  swapFee: String!
  totalSubsidy: String!
  totalWeight: String!
  weights: Weight!
  ztgQty: BigInt!
}

type PoolConnection {
  totalCount: Int!
  edges: [PoolEdge!]!
  pageInfo: PageInfo!
}

input PoolCreateInput {
  poolId: Float!
  baseAsset: String!
  marketId: Float!
  poolStatus: String!
  scoringRule: String!
  swapFee: String!
  totalSubsidy: String!
  totalWeight: String!
  weights: WeightInput!
  ztgQty: String!
}

type PoolEdge {
  node: Pool!
  cursor: String!
}

enum PoolOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  poolId_ASC
  poolId_DESC
  baseAsset_ASC
  baseAsset_DESC
  marketId_ASC
  marketId_DESC
  poolStatus_ASC
  poolStatus_DESC
  scoringRule_ASC
  scoringRule_DESC
  swapFee_ASC
  swapFee_DESC
  totalSubsidy_ASC
  totalSubsidy_DESC
  totalWeight_ASC
  totalWeight_DESC
  ztgQty_ASC
  ztgQty_DESC
}

input PoolUpdateInput {
  poolId: Float
  baseAsset: String
  marketId: Float
  poolStatus: String
  scoringRule: String
  swapFee: String
  totalSubsidy: String
  totalWeight: String
  weights: WeightInput
  ztgQty: String
}

input PoolWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  poolId_eq: Int
  poolId_gt: Int
  poolId_gte: Int
  poolId_lt: Int
  poolId_lte: Int
  poolId_in: [Int!]
  baseAsset_eq: String
  baseAsset_contains: String
  baseAsset_startsWith: String
  baseAsset_endsWith: String
  baseAsset_in: [String!]
  marketId_eq: Int
  marketId_gt: Int
  marketId_gte: Int
  marketId_lt: Int
  marketId_lte: Int
  marketId_in: [Int!]
  poolStatus_eq: String
  poolStatus_contains: String
  poolStatus_startsWith: String
  poolStatus_endsWith: String
  poolStatus_in: [String!]
  scoringRule_eq: String
  scoringRule_contains: String
  scoringRule_startsWith: String
  scoringRule_endsWith: String
  scoringRule_in: [String!]
  swapFee_eq: String
  swapFee_contains: String
  swapFee_startsWith: String
  swapFee_endsWith: String
  swapFee_in: [String!]
  totalSubsidy_eq: String
  totalSubsidy_contains: String
  totalSubsidy_startsWith: String
  totalSubsidy_endsWith: String
  totalSubsidy_in: [String!]
  totalWeight_eq: String
  totalWeight_contains: String
  totalWeight_startsWith: String
  totalWeight_endsWith: String
  totalWeight_in: [String!]
  weights_json: JSONObject
  ztgQty_eq: BigInt
  ztgQty_gt: BigInt
  ztgQty_gte: BigInt
  ztgQty_lt: BigInt
  ztgQty_lte: BigInt
  ztgQty_in: [BigInt!]
  AND: [PoolWhereInput!]
  OR: [PoolWhereInput!]
}

input PoolWhereUniqueInput {
  id: ID!
}

type ProcessorState {
  lastCompleteBlock: Float!
  lastProcessedEvent: String!
  indexerHead: Float!
  chainHead: Float!
}

type Query {
  accounts(offset: Int, limit: Int = 50, where: AccountWhereInput, orderBy: [AccountOrderByInput!]): [Account!]!
  accountByUniqueInput(where: AccountWhereUniqueInput!): Account
  accountsConnection(first: Int, after: String, last: Int, before: String, where: AccountWhereInput, orderBy: [AccountOrderByInput!]): AccountConnection!
  assetBalances(offset: Int, limit: Int = 50, where: AssetBalanceWhereInput, orderBy: [AssetBalanceOrderByInput!]): [AssetBalance!]!
  assetBalanceByUniqueInput(where: AssetBalanceWhereUniqueInput!): AssetBalance
  assetBalancesConnection(first: Int, after: String, last: Int, before: String, where: AssetBalanceWhereInput, orderBy: [AssetBalanceOrderByInput!]): AssetBalanceConnection!
  assets(offset: Int, limit: Int = 50, where: AssetWhereInput, orderBy: [AssetOrderByInput!]): [Asset!]!
  assetByUniqueInput(where: AssetWhereUniqueInput!): Asset
  assetsConnection(first: Int, after: String, last: Int, before: String, where: AssetWhereInput, orderBy: [AssetOrderByInput!]): AssetConnection!
  historicalAssetBalances(offset: Int, limit: Int = 50, where: HistoricalAssetBalanceWhereInput, orderBy: [HistoricalAssetBalanceOrderByInput!]): [HistoricalAssetBalance!]!
  historicalAssetBalanceByUniqueInput(where: HistoricalAssetBalanceWhereUniqueInput!): HistoricalAssetBalance
  historicalAssetBalancesConnection(first: Int, after: String, last: Int, before: String, where: HistoricalAssetBalanceWhereInput, orderBy: [HistoricalAssetBalanceOrderByInput!]): HistoricalAssetBalanceConnection!
  historicalAssetPrices(offset: Int, limit: Int = 50, where: HistoricalAssetPriceWhereInput, orderBy: [HistoricalAssetPriceOrderByInput!]): [HistoricalAssetPrice!]!
  historicalAssetPriceByUniqueInput(where: HistoricalAssetPriceWhereUniqueInput!): HistoricalAssetPrice
  historicalAssetPricesConnection(first: Int, after: String, last: Int, before: String, where: HistoricalAssetPriceWhereInput, orderBy: [HistoricalAssetPriceOrderByInput!]): HistoricalAssetPriceConnection!
  historicalPools(offset: Int, limit: Int = 50, where: HistoricalPoolWhereInput, orderBy: [HistoricalPoolOrderByInput!]): [HistoricalPool!]!
  historicalPoolByUniqueInput(where: HistoricalPoolWhereUniqueInput!): HistoricalPool
  historicalPoolsConnection(first: Int, after: String, last: Int, before: String, where: HistoricalPoolWhereInput, orderBy: [HistoricalPoolOrderByInput!]): HistoricalPoolConnection!
  markets(offset: Int, limit: Int = 50, where: MarketWhereInput, orderBy: [MarketOrderByInput!]): [Market!]!
  marketByUniqueInput(where: MarketWhereUniqueInput!): Market
  marketsConnection(first: Int, after: String, last: Int, before: String, where: MarketWhereInput, orderBy: [MarketOrderByInput!]): MarketConnection!
  pools(offset: Int, limit: Int = 50, where: PoolWhereInput, orderBy: [PoolOrderByInput!]): [Pool!]!
  poolByUniqueInput(where: PoolWhereUniqueInput!): Pool
  poolsConnection(first: Int, after: String, last: Int, before: String, where: PoolWhereInput, orderBy: [PoolOrderByInput!]): PoolConnection!
}

type StandardDeleteResponse {
  id: ID!
}

type Subscription {
  stateSubscription: ProcessorState!
}

type Weight {
  assetId: String!
  len: String!
}

input WeightCreateInput {
  assetId: String!
  len: String!
}

input WeightInput {
  assetId: String!
  len: String!
}

input WeightUpdateInput {
  assetId: String
  len: String
}

input WeightWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  assetId_eq: String
  assetId_contains: String
  assetId_startsWith: String
  assetId_endsWith: String
  assetId_in: [String!]
  len_eq: String
  len_contains: String
  len_startsWith: String
  len_endsWith: String
  len_in: [String!]
  AND: [WeightWhereInput!]
  OR: [WeightWhereInput!]
}

input WeightWhereUniqueInput {
  id: ID!
}
