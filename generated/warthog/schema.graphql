type Account implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!

  """Account address"""
  wallet: String!
  assetBalances: [AssetBalance!]
  historicalAssetBalances: [HistoricalAssetBalance!]
}

type AccountConnection {
  totalCount: Int!
  edges: [AccountEdge!]!
  pageInfo: PageInfo!
}

input AccountCreateInput {
  wallet: String!
}

type AccountEdge {
  node: Account!
  cursor: String!
}

enum AccountOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  wallet_ASC
  wallet_DESC
}

input AccountUpdateInput {
  wallet: String
}

input AccountWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  wallet_eq: String
  wallet_contains: String
  wallet_startsWith: String
  wallet_endsWith: String
  wallet_in: [String!]
  assetBalances_none: AssetBalanceWhereInput
  assetBalances_some: AssetBalanceWhereInput
  assetBalances_every: AssetBalanceWhereInput
  historicalAssetBalances_none: HistoricalAssetBalanceWhereInput
  historicalAssetBalances_some: HistoricalAssetBalanceWhereInput
  historicalAssetBalances_every: HistoricalAssetBalanceWhereInput
  AND: [AccountWhereInput!]
  OR: [AccountWhereInput!]
}

input AccountWhereUniqueInput {
  id: ID!
}

type AssetBalance implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  account: Account!
  accountId: String!
  assetId: String!
  balance: BigInt!
}

type AssetBalanceConnection {
  totalCount: Int!
  edges: [AssetBalanceEdge!]!
  pageInfo: PageInfo!
}

input AssetBalanceCreateInput {
  account: ID!
  assetId: String!
  balance: String!
}

type AssetBalanceEdge {
  node: AssetBalance!
  cursor: String!
}

enum AssetBalanceOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  account_ASC
  account_DESC
  assetId_ASC
  assetId_DESC
  balance_ASC
  balance_DESC
}

input AssetBalanceUpdateInput {
  account: ID
  assetId: String
  balance: String
}

input AssetBalanceWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  assetId_eq: String
  assetId_contains: String
  assetId_startsWith: String
  assetId_endsWith: String
  assetId_in: [String!]
  balance_eq: BigInt
  balance_gt: BigInt
  balance_gte: BigInt
  balance_lt: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  account: AccountWhereInput
  AND: [AssetBalanceWhereInput!]
  OR: [AssetBalanceWhereInput!]
}

input AssetBalanceWhereUniqueInput {
  id: ID!
}

interface BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModel implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

type BaseModelUUID implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
}

input BaseWhereInput {
  id_eq: String
  id_in: [String!]
  createdAt_eq: String
  createdAt_lt: String
  createdAt_lte: String
  createdAt_gt: String
  createdAt_gte: String
  createdById_eq: String
  updatedAt_eq: String
  updatedAt_lt: String
  updatedAt_lte: String
  updatedAt_gt: String
  updatedAt_gte: String
  updatedById_eq: String
  deletedAt_all: Boolean
  deletedAt_eq: String
  deletedAt_lt: String
  deletedAt_lte: String
  deletedAt_gt: String
  deletedAt_gte: String
  deletedById_eq: String
}

"""GraphQL representation of BigInt"""
scalar BigInt

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

interface DeleteResponse {
  id: ID!
}

type HistoricalAssetBalance implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  account: Account!
  accountId: String!
  event: String!
  assetId: String!
  amount: BigInt!
  balance: BigInt!
  blockNumber: Int!
  timestamp: BigInt!
}

type HistoricalAssetBalanceConnection {
  totalCount: Int!
  edges: [HistoricalAssetBalanceEdge!]!
  pageInfo: PageInfo!
}

input HistoricalAssetBalanceCreateInput {
  account: ID!
  event: String!
  assetId: String!
  amount: String!
  balance: String!
  blockNumber: Float!
  timestamp: String!
}

type HistoricalAssetBalanceEdge {
  node: HistoricalAssetBalance!
  cursor: String!
}

enum HistoricalAssetBalanceOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  account_ASC
  account_DESC
  event_ASC
  event_DESC
  assetId_ASC
  assetId_DESC
  amount_ASC
  amount_DESC
  balance_ASC
  balance_DESC
  blockNumber_ASC
  blockNumber_DESC
  timestamp_ASC
  timestamp_DESC
}

input HistoricalAssetBalanceUpdateInput {
  account: ID
  event: String
  assetId: String
  amount: String
  balance: String
  blockNumber: Float
  timestamp: String
}

input HistoricalAssetBalanceWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  event_eq: String
  event_contains: String
  event_startsWith: String
  event_endsWith: String
  event_in: [String!]
  assetId_eq: String
  assetId_contains: String
  assetId_startsWith: String
  assetId_endsWith: String
  assetId_in: [String!]
  amount_eq: BigInt
  amount_gt: BigInt
  amount_gte: BigInt
  amount_lt: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  balance_eq: BigInt
  balance_gt: BigInt
  balance_gte: BigInt
  balance_lt: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  blockNumber_eq: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  timestamp_eq: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  account: AccountWhereInput
  AND: [HistoricalAssetBalanceWhereInput!]
  OR: [HistoricalAssetBalanceWhereInput!]
}

input HistoricalAssetBalanceWhereUniqueInput {
  id: ID!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type Market implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  marketId: Int!
  creator: String!
  creation: String!
  oracle: String!
  slug: String
  question: String
  description: String
  marketType: MarketType!
  period: MarketPeriod!
  scoringRule: String!
  status: String!
  report: MarketReport
  resolvedOutcome: String
  mdm: MarketDisputeMechanism!
  marketHistory: [MarketHistory!]
}

type MarketConnection {
  totalCount: Int!
  edges: [MarketEdge!]!
  pageInfo: PageInfo!
}

input MarketCreateInput {
  marketId: Float!
  creator: String!
  creation: String!
  oracle: String!
  slug: String
  question: String
  description: String
  marketType: MarketTypeInput!
  period: MarketPeriodInput!
  scoringRule: String!
  status: String!
  report: MarketReportInput
  resolvedOutcome: String
  mdm: MarketDisputeMechanismInput!
}

type MarketDisputeMechanism {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}

input MarketDisputeMechanismCreateInput {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}

input MarketDisputeMechanismInput {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}

input MarketDisputeMechanismUpdateInput {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}

input MarketDisputeMechanismWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  authorized_eq: String
  authorized_contains: String
  authorized_startsWith: String
  authorized_endsWith: String
  authorized_in: [String!]
  court_eq: Boolean
  court_in: [Boolean!]
  simpleDisputes_eq: Boolean
  simpleDisputes_in: [Boolean!]
  AND: [MarketDisputeMechanismWhereInput!]
  OR: [MarketDisputeMechanismWhereInput!]
}

input MarketDisputeMechanismWhereUniqueInput {
  id: ID!
}

type MarketEdge {
  node: Market!
  cursor: String!
}

type MarketHistory implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  market: Market!
  marketId: String!
  event: String!
  status: String
  report: MarketReport
  resolvedOutcome: String
  blockNumber: Int!
  timestamp: BigInt!
}

type MarketHistoryConnection {
  totalCount: Int!
  edges: [MarketHistoryEdge!]!
  pageInfo: PageInfo!
}

input MarketHistoryCreateInput {
  market: ID!
  event: String!
  status: String
  report: MarketReportInput
  resolvedOutcome: String
  blockNumber: Float!
  timestamp: String!
}

type MarketHistoryEdge {
  node: MarketHistory!
  cursor: String!
}

enum MarketHistoryOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  market_ASC
  market_DESC
  event_ASC
  event_DESC
  status_ASC
  status_DESC
  resolvedOutcome_ASC
  resolvedOutcome_DESC
  blockNumber_ASC
  blockNumber_DESC
  timestamp_ASC
  timestamp_DESC
}

input MarketHistoryUpdateInput {
  market: ID
  event: String
  status: String
  report: MarketReportInput
  resolvedOutcome: String
  blockNumber: Float
  timestamp: String
}

input MarketHistoryWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  event_eq: String
  event_contains: String
  event_startsWith: String
  event_endsWith: String
  event_in: [String!]
  status_eq: String
  status_contains: String
  status_startsWith: String
  status_endsWith: String
  status_in: [String!]
  report_json: JSONObject
  resolvedOutcome_eq: String
  resolvedOutcome_contains: String
  resolvedOutcome_startsWith: String
  resolvedOutcome_endsWith: String
  resolvedOutcome_in: [String!]
  blockNumber_eq: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  timestamp_eq: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  market: MarketWhereInput
  AND: [MarketHistoryWhereInput!]
  OR: [MarketHistoryWhereInput!]
}

input MarketHistoryWhereUniqueInput {
  id: ID!
}

enum MarketOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  marketId_ASC
  marketId_DESC
  creator_ASC
  creator_DESC
  creation_ASC
  creation_DESC
  oracle_ASC
  oracle_DESC
  slug_ASC
  slug_DESC
  question_ASC
  question_DESC
  description_ASC
  description_DESC
  scoringRule_ASC
  scoringRule_DESC
  status_ASC
  status_DESC
  resolvedOutcome_ASC
  resolvedOutcome_DESC
}

type MarketPeriod {
  block: String
  timestamp: String
}

input MarketPeriodCreateInput {
  block: String
  timestamp: String
}

input MarketPeriodInput {
  block: String
  timestamp: String
}

input MarketPeriodUpdateInput {
  block: String
  timestamp: String
}

input MarketPeriodWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  block_eq: String
  block_contains: String
  block_startsWith: String
  block_endsWith: String
  block_in: [String!]
  timestamp_eq: String
  timestamp_contains: String
  timestamp_startsWith: String
  timestamp_endsWith: String
  timestamp_in: [String!]
  AND: [MarketPeriodWhereInput!]
  OR: [MarketPeriodWhereInput!]
}

input MarketPeriodWhereUniqueInput {
  id: ID!
}

type MarketReport {
  at: Int!
  by: String!
  outcome: OutcomeReport!
}

input MarketReportCreateInput {
  at: Float!
  by: String!
}

input MarketReportInput {
  at: Int!
  by: String!
  outcome: OutcomeReportInput!
}

input MarketReportUpdateInput {
  at: Float
  by: String
}

input MarketReportWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  at_eq: Int
  at_gt: Int
  at_gte: Int
  at_lt: Int
  at_lte: Int
  at_in: [Int!]
  by_eq: String
  by_contains: String
  by_startsWith: String
  by_endsWith: String
  by_in: [String!]
  AND: [MarketReportWhereInput!]
  OR: [MarketReportWhereInput!]
}

input MarketReportWhereUniqueInput {
  id: ID!
}

type MarketType {
  categorical: String
  scalar: String
}

input MarketTypeCreateInput {
  categorical: String
  scalar: String
}

input MarketTypeInput {
  categorical: String
  scalar: String
}

input MarketTypeUpdateInput {
  categorical: String
  scalar: String
}

input MarketTypeWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  categorical_eq: String
  categorical_contains: String
  categorical_startsWith: String
  categorical_endsWith: String
  categorical_in: [String!]
  scalar_eq: String
  scalar_contains: String
  scalar_startsWith: String
  scalar_endsWith: String
  scalar_in: [String!]
  AND: [MarketTypeWhereInput!]
  OR: [MarketTypeWhereInput!]
}

input MarketTypeWhereUniqueInput {
  id: ID!
}

input MarketUpdateInput {
  marketId: Float
  creator: String
  creation: String
  oracle: String
  slug: String
  question: String
  description: String
  marketType: MarketTypeInput
  period: MarketPeriodInput
  scoringRule: String
  status: String
  report: MarketReportInput
  resolvedOutcome: String
  mdm: MarketDisputeMechanismInput
}

input MarketWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  marketId_eq: Int
  marketId_gt: Int
  marketId_gte: Int
  marketId_lt: Int
  marketId_lte: Int
  marketId_in: [Int!]
  creator_eq: String
  creator_contains: String
  creator_startsWith: String
  creator_endsWith: String
  creator_in: [String!]
  creation_eq: String
  creation_contains: String
  creation_startsWith: String
  creation_endsWith: String
  creation_in: [String!]
  oracle_eq: String
  oracle_contains: String
  oracle_startsWith: String
  oracle_endsWith: String
  oracle_in: [String!]
  slug_eq: String
  slug_contains: String
  slug_startsWith: String
  slug_endsWith: String
  slug_in: [String!]
  question_eq: String
  question_contains: String
  question_startsWith: String
  question_endsWith: String
  question_in: [String!]
  description_eq: String
  description_contains: String
  description_startsWith: String
  description_endsWith: String
  description_in: [String!]
  marketType_json: JSONObject
  period_json: JSONObject
  scoringRule_eq: String
  scoringRule_contains: String
  scoringRule_startsWith: String
  scoringRule_endsWith: String
  scoringRule_in: [String!]
  status_eq: String
  status_contains: String
  status_startsWith: String
  status_endsWith: String
  status_in: [String!]
  report_json: JSONObject
  resolvedOutcome_eq: String
  resolvedOutcome_contains: String
  resolvedOutcome_startsWith: String
  resolvedOutcome_endsWith: String
  resolvedOutcome_in: [String!]
  mdm_json: JSONObject
  marketHistory_none: MarketHistoryWhereInput
  marketHistory_some: MarketHistoryWhereInput
  marketHistory_every: MarketHistoryWhereInput
  AND: [MarketWhereInput!]
  OR: [MarketWhereInput!]
}

input MarketWhereUniqueInput {
  id: ID!
}

type OutcomeReport {
  categorical: Int
  scalar: Int
}

input OutcomeReportCreateInput {
  categorical: Float
  scalar: Float
}

input OutcomeReportInput {
  categorical: Int
  scalar: Int
}

input OutcomeReportUpdateInput {
  categorical: Float
  scalar: Float
}

input OutcomeReportWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  categorical_eq: Int
  categorical_gt: Int
  categorical_gte: Int
  categorical_lt: Int
  categorical_lte: Int
  categorical_in: [Int!]
  scalar_eq: Int
  scalar_gt: Int
  scalar_gte: Int
  scalar_lt: Int
  scalar_lte: Int
  scalar_in: [Int!]
  AND: [OutcomeReportWhereInput!]
  OR: [OutcomeReportWhereInput!]
}

input OutcomeReportWhereUniqueInput {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pool implements BaseGraphQLObject {
  id: ID!
  createdAt: DateTime!
  createdById: String!
  updatedAt: DateTime
  updatedById: String
  deletedAt: DateTime
  deletedById: String
  version: Int!
  poolId: Int!
  baseAsset: String!
  marketId: Int!
  poolStatus: String!
  scoringRule: String!
  swapFee: String!
  totalSubsidy: String!
  totalWeight: String!
  blockNumber: Int!
  timestamp: BigInt!
}

type PoolConnection {
  totalCount: Int!
  edges: [PoolEdge!]!
  pageInfo: PageInfo!
}

input PoolCreateInput {
  poolId: Float!
  baseAsset: String!
  marketId: Float!
  poolStatus: String!
  scoringRule: String!
  swapFee: String!
  totalSubsidy: String!
  totalWeight: String!
  blockNumber: Float!
  timestamp: String!
}

type PoolEdge {
  node: Pool!
  cursor: String!
}

enum PoolOrderByInput {
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  deletedAt_ASC
  deletedAt_DESC
  poolId_ASC
  poolId_DESC
  baseAsset_ASC
  baseAsset_DESC
  marketId_ASC
  marketId_DESC
  poolStatus_ASC
  poolStatus_DESC
  scoringRule_ASC
  scoringRule_DESC
  swapFee_ASC
  swapFee_DESC
  totalSubsidy_ASC
  totalSubsidy_DESC
  totalWeight_ASC
  totalWeight_DESC
  blockNumber_ASC
  blockNumber_DESC
  timestamp_ASC
  timestamp_DESC
}

input PoolUpdateInput {
  poolId: Float
  baseAsset: String
  marketId: Float
  poolStatus: String
  scoringRule: String
  swapFee: String
  totalSubsidy: String
  totalWeight: String
  blockNumber: Float
  timestamp: String
}

input PoolWhereInput {
  id_eq: ID
  id_in: [ID!]
  createdAt_eq: DateTime
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdById_eq: ID
  createdById_in: [ID!]
  updatedAt_eq: DateTime
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedById_eq: ID
  updatedById_in: [ID!]
  deletedAt_all: Boolean
  deletedAt_eq: DateTime
  deletedAt_lt: DateTime
  deletedAt_lte: DateTime
  deletedAt_gt: DateTime
  deletedAt_gte: DateTime
  deletedById_eq: ID
  deletedById_in: [ID!]
  poolId_eq: Int
  poolId_gt: Int
  poolId_gte: Int
  poolId_lt: Int
  poolId_lte: Int
  poolId_in: [Int!]
  baseAsset_eq: String
  baseAsset_contains: String
  baseAsset_startsWith: String
  baseAsset_endsWith: String
  baseAsset_in: [String!]
  marketId_eq: Int
  marketId_gt: Int
  marketId_gte: Int
  marketId_lt: Int
  marketId_lte: Int
  marketId_in: [Int!]
  poolStatus_eq: String
  poolStatus_contains: String
  poolStatus_startsWith: String
  poolStatus_endsWith: String
  poolStatus_in: [String!]
  scoringRule_eq: String
  scoringRule_contains: String
  scoringRule_startsWith: String
  scoringRule_endsWith: String
  scoringRule_in: [String!]
  swapFee_eq: String
  swapFee_contains: String
  swapFee_startsWith: String
  swapFee_endsWith: String
  swapFee_in: [String!]
  totalSubsidy_eq: String
  totalSubsidy_contains: String
  totalSubsidy_startsWith: String
  totalSubsidy_endsWith: String
  totalSubsidy_in: [String!]
  totalWeight_eq: String
  totalWeight_contains: String
  totalWeight_startsWith: String
  totalWeight_endsWith: String
  totalWeight_in: [String!]
  blockNumber_eq: Int
  blockNumber_gt: Int
  blockNumber_gte: Int
  blockNumber_lt: Int
  blockNumber_lte: Int
  blockNumber_in: [Int!]
  timestamp_eq: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  AND: [PoolWhereInput!]
  OR: [PoolWhereInput!]
}

input PoolWhereUniqueInput {
  id: ID!
}

type ProcessorState {
  lastCompleteBlock: Float!
  lastProcessedEvent: String!
  indexerHead: Float!
  chainHead: Float!
}

type Query {
  accounts(offset: Int, limit: Int = 50, where: AccountWhereInput, orderBy: [AccountOrderByInput!]): [Account!]!
  accountByUniqueInput(where: AccountWhereUniqueInput!): Account
  accountsConnection(first: Int, after: String, last: Int, before: String, where: AccountWhereInput, orderBy: [AccountOrderByInput!]): AccountConnection!
  assetBalances(offset: Int, limit: Int = 50, where: AssetBalanceWhereInput, orderBy: [AssetBalanceOrderByInput!]): [AssetBalance!]!
  assetBalanceByUniqueInput(where: AssetBalanceWhereUniqueInput!): AssetBalance
  assetBalancesConnection(first: Int, after: String, last: Int, before: String, where: AssetBalanceWhereInput, orderBy: [AssetBalanceOrderByInput!]): AssetBalanceConnection!
  historicalAssetBalances(offset: Int, limit: Int = 50, where: HistoricalAssetBalanceWhereInput, orderBy: [HistoricalAssetBalanceOrderByInput!]): [HistoricalAssetBalance!]!
  historicalAssetBalanceByUniqueInput(where: HistoricalAssetBalanceWhereUniqueInput!): HistoricalAssetBalance
  historicalAssetBalancesConnection(first: Int, after: String, last: Int, before: String, where: HistoricalAssetBalanceWhereInput, orderBy: [HistoricalAssetBalanceOrderByInput!]): HistoricalAssetBalanceConnection!
  marketHistories(offset: Int, limit: Int = 50, where: MarketHistoryWhereInput, orderBy: [MarketHistoryOrderByInput!]): [MarketHistory!]!
  marketHistoryByUniqueInput(where: MarketHistoryWhereUniqueInput!): MarketHistory
  marketHistoriesConnection(first: Int, after: String, last: Int, before: String, where: MarketHistoryWhereInput, orderBy: [MarketHistoryOrderByInput!]): MarketHistoryConnection!
  markets(offset: Int, limit: Int = 50, where: MarketWhereInput, orderBy: [MarketOrderByInput!]): [Market!]!
  marketByUniqueInput(where: MarketWhereUniqueInput!): Market
  marketsConnection(first: Int, after: String, last: Int, before: String, where: MarketWhereInput, orderBy: [MarketOrderByInput!]): MarketConnection!
  pools(offset: Int, limit: Int = 50, where: PoolWhereInput, orderBy: [PoolOrderByInput!]): [Pool!]!
  poolByUniqueInput(where: PoolWhereUniqueInput!): Pool
  poolsConnection(first: Int, after: String, last: Int, before: String, where: PoolWhereInput, orderBy: [PoolOrderByInput!]): PoolConnection!
}

type StandardDeleteResponse {
  id: ID!
}

type Subscription {
  stateSubscription: ProcessorState!
}
