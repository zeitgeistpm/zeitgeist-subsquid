type Account @entity {
  "Account address"
  accountId: String!
  poolId: Int
}

"""
Balance of a particular asset denoted by assetId present in the account
"""
type AccountBalance @entity {
  "Unique identifier of the object"
  id: ID!
  "Connected account"
  account: Account!
  "Zeitgeist's identifier of the asset"
  assetId: String!
  "Balance of the asset"
  balance: BigInt!
}

"""
Balance history of a particular asset in an account. Records all transactions
associated with the account.
"""
type HistoricalAccountBalance @entity {
  "Unique identifier of the object"
  id: ID!
  "Account address"
  accountId: String!
  "Zeitgeist's identifier of the asset"
  assetId: String!
  "Balance difference"
  amount: BigInt!
  "Net balance"
  balance: BigInt!
  "Event method which initiated this change"
  event: String!
  "Height of the block"
  blockNumber: Int!
  "Timestamp of the block"
  timestamp: DateTime!
}

"""
A type that has detail of the outcome asset. It is initialised as soon as the
market is created and price is assigned when pool is deployed for the market.
"""
type Asset @entity {
  "Unique identifier of the object"
  id: ID!
  "Zeitgeist's identifier of the asset"
  assetId: String!
  "Zeitgeist's identifier of the pool"
  poolId: Int
  "Spot price of the asset in the pool"
  price: Float
  "Balance of the asset present in the pool account"
  qty: BigInt
}

"""
Price history of the outcome asset
"""
type HistoricalAsset @entity {
  "Unique identifier of the object"
  id: ID!
  "Zeitgeist's identifier of the asset"
  assetId: String!
  "Price difference"
  dPrice: Float
  "Balance difference"
  dQty: BigInt!
  "Spot price of the asset"
  price: Float
  "Balance in the pool account"
  qty: BigInt!
  "Event method which initiated this change"
  event: String!
  "Height of the block"
  blockNumber: Int!
  "Timestamp of the block"
  timestamp: DateTime!
}

"""
Prediction market details
"""
type Market @entity {
  "Unique identifier of the object"
  id: ID!
  "Zeitgeist's identifier of the market"
  marketId: Int!
  "Account address of the market creator" 
  creator: String!
  "Can be `Permissionless` or `Advised`"
  creation: String!
  creatorFee: Int
  oracle: String!
  outcomeAssets: [String]!
  slug: String
  question: String
  description: String
  categories: [CategoryMetadata]
  tags: [String]
  img: String
  marketType: MarketType!
  period: MarketPeriod!
  end: BigInt!
  scoringRule: String!
  status: String!
  poolId: Int
  report: MarketReport
  resolvedOutcome: String
  mdm: MarketDisputeMechanism!
}

type HistoricalMarket @entity {
  marketId: Int!
  event: String!
  status: String
  poolId: Int
  report: MarketReport
  resolvedOutcome: String
  blockNumber: Int!
  timestamp: DateTime!
}

type Pool @entity {
  poolId: Int!
  accountId: String
  baseAsset: String!
  marketId: Int!
  poolStatus: String!
  scoringRule: String!
  swapFee: String!
  totalSubsidy: String!
  totalWeight: String!
  weights: [Weight]!
  ztgQty: BigInt!
  volume: BigInt!
}

type HistoricalPool @entity {
  poolId: Int!
  event: String!
  ztgQty: BigInt!
  volume: BigInt
  blockNumber: Int!
  timestamp: DateTime!
}

type Weight @jsonField {
  assetId: String!
  len: BigInt!
}

type CategoryMetadata @jsonField {
  name: String
  ticker: String
  img: String
  color: String
}

type MarketType @jsonField {
  categorical: String
  scalar: String
}

type MarketPeriod @jsonField {
  block: String
  timestamp: String
}

enum MarketStatus {
  Active,
  CollectingSubsidy,
  InsufficientSubsidy,
  Reported,
  Disputed,
  Rejected,
  Cancelled
}

type MarketReport @jsonField {
  at: Int!
  by: String!
  outcome: OutcomeReport!
}

type OutcomeReport @jsonField {
  categorical: Int
  scalar: Int
}

type MarketDisputeMechanism @jsonField {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}