"""
A type that has ss58 address format of the account. As soon as the chain
encounters any new address, they get registered here as user or pool account.
"""
type Account @entity {
  "Unique identifier of the object"
  id: ID!
  "Account address"
  accountId: String!
  "Zeitgeist's identifier for pool. Valid only for pool account."
  poolId: Int
}

"""
Balance of a particular asset denoted by assetId present in the account
"""
type AccountBalance @entity {
  "Unique identifier of the object"
  id: ID!
  "Connected account"
  account: Account!
  "Zeitgeist's identifier for asset"
  assetId: String!
  "Balance of the asset"
  balance: BigInt!
}

"""
Balance history of a particular asset in an account. Records all transactions
associated with the account.
"""
type HistoricalAccountBalance @entity {
  "Unique identifier of the object"
  id: ID!
  "Account address"
  accountId: String!
  "Zeitgeist's identifier for asset"
  assetId: String!
  "Balance difference"
  amount: BigInt!
  "Net balance"
  balance: BigInt!
  "Event method which initiated this change"
  event: String!
  "Height of the block"
  blockNumber: Int!
  "Timestamp of the block"
  timestamp: DateTime!
}

"""
A type that has detail of the outcome asset. It is initialised as soon as the
market is created and price is assigned when pool is deployed for the market.
"""
type Asset @entity {
  "Unique identifier of the object"
  id: ID!
  "Zeitgeist's identifier for asset"
  assetId: String!
  "Zeitgeist's identifier for pool"
  poolId: Int
  "Spot price of the asset in the pool"
  price: Float
  "Balance of the asset present in the pool account"
  qty: BigInt
}

"""
Price history of the outcome asset
"""
type HistoricalAsset @entity {
  "Unique identifier of the object"
  id: ID!
  "Zeitgeist's identifier for asset"
  assetId: String!
  "Price difference"
  dPrice: Float
  "Balance difference"
  dQty: BigInt!
  "Spot price of the asset"
  price: Float
  "Balance in the pool account"
  qty: BigInt!
  "Event method which initiated this change"
  event: String!
  "Height of the block"
  blockNumber: Int!
  "Timestamp of the block"
  timestamp: DateTime!
}

"""
Prediction market details
"""
type Market @entity {
  "Unique identifier of the object"
  id: ID!
  "Zeitgeist's identifier for market"
  marketId: Int!
  "Account address of the market creator" 
  creator: String!
  "Can be `Permissionless` or `Advised`"
  creation: String!
  "The creator's fee"
  creatorFee: Int
  "Account designated to report on the market"
  oracle: String!
  "Share identifiers"
  outcomeAssets: [String]!
  "Short name for the market"
  slug: String
  "Market question"
  question: String
  "Description of the market"
  description: String
  "Share details"
  categories: [CategoryMetadata]
  "Market tags"
  tags: [String]
  "Image for the market"
  img: String
  "Type of the market"
  marketType: MarketType!
  "Time period expressed in block numbers or timestamps"
  period: MarketPeriod!
  "Timestamp at which market should end"
  end: BigInt!
  "Scoring rule used for the market"
  scoringRule: String!
  "Status of the market"
  status: String!
  "Zeitgeist's indentifier for liquidity pool"
  poolId: Int
  "Reported outcome of the market. Null if the market is not reported yet"
  report: MarketReport
  "Resolved outcome for the market"
  resolvedOutcome: String
  "Can be `authorized` or `court` or `simpleDisputes`"
  mdm: MarketDisputeMechanism!
}

type HistoricalMarket @entity {
  marketId: Int!
  event: String!
  status: String
  poolId: Int
  report: MarketReport
  resolvedOutcome: String
  blockNumber: Int!
  timestamp: DateTime!
}

type Pool @entity {
  poolId: Int!
  accountId: String
  baseAsset: String!
  marketId: Int!
  poolStatus: String!
  scoringRule: String!
  swapFee: String!
  totalSubsidy: String!
  totalWeight: String!
  weights: [Weight]!
  ztgQty: BigInt!
  volume: BigInt!
}

type HistoricalPool @entity {
  poolId: Int!
  event: String!
  ztgQty: BigInt!
  volume: BigInt
  blockNumber: Int!
  timestamp: DateTime!
}

type Weight @jsonField {
  assetId: String!
  len: BigInt!
}

type CategoryMetadata @jsonField {
  name: String
  ticker: String
  img: String
  color: String
}

type MarketType @jsonField {
  categorical: String
  scalar: String
}

type MarketPeriod @jsonField {
  block: String
  timestamp: String
}

enum MarketStatus {
  Active,
  CollectingSubsidy,
  InsufficientSubsidy,
  Reported,
  Disputed,
  Rejected,
  Cancelled
}

type MarketReport @jsonField {
  at: Int!
  by: String!
  outcome: OutcomeReport!
}

type OutcomeReport @jsonField {
  categorical: Int
  scalar: Int
}

type MarketDisputeMechanism @jsonField {
  authorized: String
  court: Boolean
  simpleDisputes: Boolean
}